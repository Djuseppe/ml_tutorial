---

title: Convolutional Neural Networks

keywords: fastai
sidebar: home_sidebar

summary: "Summary: Convolutional Neural Networks, CNNs, ConvNets, Gradient Descent, Backpropagation"
description: "Summary: Convolutional Neural Networks, CNNs, ConvNets, Gradient Descent, Backpropagation"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: 06_cnn.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
    {% raw %}
        
<div class="cell border-box-sizing code_cell rendered">

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Convolutional-Neural-Networks-(CNNs-/-ConvNets)">Convolutional Neural Networks (CNNs / ConvNets)<a class="anchor-link" href="#Convolutional-Neural-Networks-(CNNs-/-ConvNets)"> </a></h2><p>Convolutional neural networks as very similar to the ordinary <a href="05_neural_network.ipynb">feed-forward neural networks</a>. They differ in the sense that CNNs assume explicitly that the inputs are images, which enables us to encode specific properties in the architecture to recognize certain patterns in the images. The CNNs make use of <em>spatial</em> nature of the data. It means, CNNs perceive the objects similar to our perception of different objects in nature. For example, we recognize various objects by their shapes, size and colors. These objects are combinations of edges, corners, color patches, etc. CNNs can use a variety of detectors (such as edge detectors, corner detectors) to interpret images. These detectors are called <strong>filters</strong> or <strong>kernels</strong>. The mathematical operator that takes an image and a filter as input and produces a filtered output (e.g. edges, corners, etc. ) is called <strong>convolution</strong>.</p>
<p><img src="/ml_tutorial/images/cnn_filter.jpg" alt="">
<em>Learned features in a CNN. [<a href="https://medium.com/diaryofawannapreneur/deep-learning-for-computer-vision-for-the-average-person-861661d8aa61">Image Source</a>]</em></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="CNNs-Architecture">CNNs Architecture<a class="anchor-link" href="#CNNs-Architecture"> </a></h2><p>Convolutional Neural Networks have a different architecture than regular Neural Networks. CNNs are organized in 3 dimensions (width, height and depth). Also,
Unlike ordinary neural networks that each neuron in one layer is connected to all the neurons in the next layer, in a CNN, only a small number of the neurons in the current layer connects to neurons in the next layer.</p>
<p><img src="/ml_tutorial/images/cnn_architecture.png" alt="">
<em>Architecture of a CNN. [<a href="https://www.mathworks.com/videos/introduction-to-deep-learning-what-are-convolutional-neural-networks--1489512765771.html">Image Source</a>]</em></p>
<p>ConvNets have three types of layers: <strong>Convolutional Layer</strong>, <strong>Pooling Layer</strong> and <strong>Fully-Connected Layer</strong>. By stacking these layers we can construct a convolutional neural network.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Convolutional-Layer">Convolutional Layer<a class="anchor-link" href="#Convolutional-Layer"> </a></h3><p>Convolutional layer applies a convolution operator on the input data using a filter and produces an output that is called <strong>feature map</strong>. The purpose of the convolution operation is to extract the high-level features such as edges, from the input image. The first ConvLayer is captures the Low-Level features such as edges, color, orientation, etc. Adding more layers enables the architecture to adapt to the high-level features as well, giving us a network which has the wholesome understanding of images in the dataset.</p>
<p>We execute a convolution by sliding the filter over the input. At every location, an element-wise matrix multiplication is performed and sums the result onto the feature map.</p>
<p><img src="/ml_tutorial/images/cnn_convolution.gif" alt="">
<em>Left: the filter slides over the input. Right: the result is summed and added to the feature map. [<a href="https://towardsdatascience.com/applied-deep-learning-part-4-convolutional-neural-networks-584bc134c1e2">Image Source</a>]</em></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The example above was a convolution operation shown in 2D using a 3x3 filter. But in reality these convolutions are performed in 3D because an image is represented as a 3D matrix with dimensions of width, height and depth, where depth corresponds to color channels (RGB). Therefore, a convolution filter covers the entire depth of its input so it must be 3D as well.</p>
<p><img src="/ml_tutorial/images/cnn_convolution_2.png" alt="">
<em>The filter of size 5x5x3 slides over the volume of input. [<a href="https://towardsdatascience.com/applied-deep-learning-part-4-convolutional-neural-networks-584bc134c1e2">Image Source</a>]</em></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We perform many convolutions on our input, where each convolution operation uses a different filter. This results in different feature maps. At the end, we stack all of these feature maps together and form the final output of the convolution layer.</p>
<p><img src="/ml_tutorial/images/cnn_convolution_3.png" alt="">
<em>Example of two filters (green and red) over the volume of input. [<a href="https://towardsdatascience.com/applied-deep-learning-part-4-convolutional-neural-networks-584bc134c1e2">Image Source</a>]</em></p>
<p>In order to make our output non-linear, we pass the result of the convolution operation through an activation function (usually ReLU). Thus, the values in the final feature maps are not actually the sums, but the ReLU function applied to them.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Stride-and-Padding">Stride and Padding<a class="anchor-link" href="#Stride-and-Padding"> </a></h3><p><strong>Stride</strong> is the size of the step we move the convolution filter at each step. The default value of the stride is 1.</p>
<p><img src="/ml_tutorial/images/cnn_stride1.gif" alt="">
<em>Stride with value of 1. [<a href="https://towardsdatascience.com/applied-deep-learning-part-4-convolutional-neural-networks-584bc134c1e2">Image Source</a>]</em></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>If we increase the size of stride the feature map will get smaller. The figure below demonstrates a stride of 2.</p>
<p><img src="/ml_tutorial/images/cnn_stride2.gif" alt="">
<em>Stride with value of 2. [<a href="https://towardsdatascience.com/applied-deep-learning-part-4-convolutional-neural-networks-584bc134c1e2">Image Source</a>]</em></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can see that the size of the feature map feature is reduced in dimensionality as compared to the input. If we want to prevent the feature map from shrinking, we apply <strong>padding</strong> to surround the input with zeros.</p>
<p><img src="/ml_tutorial/images/cnn_padding1.gif" alt="">
<em>Stride = 1 with padding = 1. [<a href="https://www.cntk.ai/pythondocs/CNTK_103D_MNIST_ConvolutionalNeuralNetwork.html">Image Source</a>]</em></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Pooling-Layer">Pooling Layer<a class="anchor-link" href="#Pooling-Layer"> </a></h3><p>After a convolution layer we usually perform <em>pooling</em> to reduce the dimensionality. This allows us to reduce the number of parameters, which both shortens the training time and prevents overfitting. Pooling layers downsample each feature map independently, reducing the width and height and keeping the depth intact. <em>max pooling</em> is the most common types of pooling, which takes the maximum value in each window. Pooling does not have any parameters. It just decreases the size of the feature map while at the same time keeping the important information (i.e. dominant features).</p>
<p><img src="/ml_tutorial/images/cnn_maxpooling.png" alt="">
<em>Max pooling takes the largest value. [<a href="https://www.cntk.ai/pythondocs/CNTK_103D_MNIST_ConvolutionalNeuralNetwork.html">Image Source</a>]</em></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Hyperparameters">Hyperparameters<a class="anchor-link" href="#Hyperparameters"> </a></h3><p>When using ConvNets, there are certain <em>hyperparameters</em> that we need to determine.</p>
<ol>
<li>Filter size (kernel size): 3x3 filter are very common, but 5x5 and 7x7 are also used depending on the application.</li>
<li>Filter count: How many filters do we want to use. Itâ€™s a power of two anywhere between 32 and 1024. The more filters, the more powerful model. However, there is a possibility of overfitting due to large amount of parameters. Therefore, we usually start off with a small number of filters at the initial layers, and gradually increase the count as we go deeper into the network.</li>
<li>Stride: The common stride value is 1</li>
<li>Padding:</li>
</ol>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Fully-Connected-Layer-(FC-Layer)">Fully Connected Layer (FC Layer)<a class="anchor-link" href="#Fully-Connected-Layer-(FC-Layer)"> </a></h3><p>We often have a couple of fully connected layers after convolution and pooling layers. Fully connected layers work as a classifier on top of these learned features. The last fully connected layer outputs a N dimensional vector where N is the number of classes. For example, for a digit classification CNN, N would be 10 since we have 10 digits.
 Please note that the output of both convolution and pooling layers are 3D volumes, but a fully connected layer only accepts a 1D vector of numbers. Therefore, we <strong><em>flatten</em></strong> the 3D volume, meaning we convert the 3D volume into 1D vector.</p>
<p><img src="/ml_tutorial/images/cnn_fc.jpeg" alt="">
<em>A CNN to classify handwritten digits. [<a href="https://towardsdatascience.com/a-comprehensive-guide-to-convolutional-neural-networks-the-eli5-way-3bd2b1164a53">Image Source</a>]</em></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Training-ConvNets">Training ConvNets<a class="anchor-link" href="#Training-ConvNets"> </a></h2><p>Training CNNs is the same as ordinary neural networks. We apply backpropagation with gradient descent. For reading about training neural networks please see <a href="05_neural_network.ipynb">here</a>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="ConvNets-Architectures">ConvNets Architectures<a class="anchor-link" href="#ConvNets-Architectures"> </a></h2><p>This section is adopted from Stanford University course <a href="http://cs231n.github.io/convolutional-networks/">here</a>. Convolutional Networks are often made up of only three layer types: CONV, POOL (i.e. Max Pooling), FC. Therefore, the most common architecture pattern is as follows:</p>
<p><code>INPUT -&gt; [[CONV -&gt; RELU]*N -&gt; POOL?]*M -&gt; [FC -&gt; RELU]*K -&gt; FC</code></p>
<p>where the <code>*</code> indicates repetition, and the <code>POOL?</code> indicates an optional pooling layer. Moreover, <code>N &gt;= 0</code> (and usually <code>N &lt;= 3</code>), <code>M &gt;= 0</code>, <code>K &gt;= 0</code> (and usually <code>K &lt; 3</code>).</p>
<p>There are several architectures of CNNs available  that are very popular:</p>
<ul>
<li>LeNet</li>
<li>AlexNet</li>
<li>ZF Net</li>
<li>GoogLeNet</li>
<li>VGGNet</li>
<li>ResNet</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Implementation">Implementation<a class="anchor-link" href="#Implementation"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Extra-Rsources">Extra Rsources<a class="anchor-link" href="#Extra-Rsources"> </a></h2><p>[1] <a href="http://cs231n.github.io/convolutional-networks/">Stanford course on Convolutional Neural networks</a></p>
<p>[2] <a href="https://adeshpande3.github.io/adeshpande3.github.io/A-Beginner&#39;s-Guide-To-Understanding-Convolutional-Neural-Networks/">A Beginner's Guide To Understanding Convolutional Neural Networks</a></p>
<p>[3] <a href="https://towardsdatascience.com/applied-deep-learning-part-4-convolutional-neural-networks-584bc134c1e2">Convolutional Neural Networks</a></p>

</div>
</div>
</div>
    {% endraw %}
</div>
 

